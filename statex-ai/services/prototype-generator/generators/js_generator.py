"""
JavaScript functionality generator using AI models.
"""

import httpx
import logging
from typing import Dict, Any
import json

logger = logging.getLogger(__name__)

class JSGenerator:
    """Generates JavaScript functionality using AI models."""
    
    def __init__(self, free_ai_service_url: str = "http://localhost:8016"):
        """Initialize JS generator."""
        self.free_ai_service_url = free_ai_service_url
        
    async def generate_js(self, html_content: str, requirements: str, analysis: Dict[str, Any]) -> str:
        """Generate JavaScript functionality based on HTML content and requirements."""
        try:
            # Create prompt for JavaScript generation
            prompt = self._create_js_prompt(html_content, requirements, analysis)
            
            logger.info("🚀 Calling Free AI Service for JavaScript generation")
            
            # Call Free AI Service using the correct /analyze endpoint
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.free_ai_service_url}/analyze",
                    json={
                        "text_content": prompt,
                        "analysis_type": "content_generation",
                        "provider": "mock"  # Use mock for now since Ollama/HuggingFace are unavailable
                    },
                    timeout=30.0
                )
                
                if response.status_code == 200:
                    result = response.json()
                    
                    if result.get("success", False):
                        # Extract JavaScript from the analysis response
                        analysis_data = result.get("analysis", {})
                        js_content = analysis_data.get("generated_content", "")
                        
                        if not js_content:
                            # If no generated content, try to extract from other fields
                            js_content = analysis_data.get("javascript_code", "")
                        
                        if not js_content:
                            logger.warning("⚠️ No JavaScript content generated by AI service, using fallback")
                            return self._generate_fallback_js(html_content, requirements)
                        
                        # Clean and validate JavaScript
                        js_content = self._clean_js(js_content)
                        
                        logger.info(f"✅ Successfully generated JavaScript using {result.get('provider_used', 'unknown')}")
                        return js_content
                    else:
                        logger.error(f"❌ AI service returned error: {result.get('error', 'Unknown error')}")
                        return self._generate_fallback_js(html_content, requirements)
                else:
                    logger.error(f"❌ AI service HTTP error: {response.status_code} - {response.text}")
                    return self._generate_fallback_js(html_content, requirements)
                    
        except httpx.TimeoutException:
            logger.error("❌ AI service timeout - using fallback JavaScript")
            return self._generate_fallback_js(html_content, requirements)
        except Exception as e:
            logger.error(f"❌ Error generating JavaScript: {e}", exc_info=True)
            return self._generate_fallback_js(html_content, requirements)
    
    def _create_js_prompt(self, html_content: str, requirements: str, analysis: Dict[str, Any]) -> str:
        """Create prompt for JavaScript generation."""
        
        prompt = f"""
Generate modern JavaScript functionality for this HTML content:

HTML CONTENT:
{html_content[:2000]}...

REQUIREMENTS: {requirements}

ANALYSIS: {json.dumps(analysis, indent=2)}

Please generate JavaScript that includes:
1. Smooth animations and transitions
2. Form validation and submission
3. Interactive elements (buttons, modals, etc.)
4. Mobile-friendly touch events
5. Shopping cart functionality (if e-commerce)
6. Smooth scrolling navigation
7. Image lazy loading
8. Modern ES6+ syntax
9. Error handling
10. Performance optimizations

Make it clean, well-commented, and production-ready.

Return ONLY the JavaScript code, no explanations or markdown formatting.
"""
        
        return prompt
    
    def _clean_js(self, js_content: str) -> str:
        """Clean and validate generated JavaScript."""
        # Remove markdown code blocks if present
        if js_content.startswith("```javascript"):
            js_content = js_content[12:]
        if js_content.startswith("```js"):
            js_content = js_content[5:]
        if js_content.startswith("```"):
            js_content = js_content[3:]
        if js_content.endswith("```"):
            js_content = js_content[:-3]
        
        return js_content.strip()
    
    def _generate_fallback_js(self, html_content: str, requirements: str) -> str:
        """Generate fallback JavaScript when AI service fails."""
        
        return """// Modern JavaScript for Prototype
document.addEventListener('DOMContentLoaded', function() {
    // Initialize all functionality
    initSmoothScrolling();
    initFormValidation();
    initAnimations();
    initShoppingCart();
    initMobileMenu();
    initLazyLoading();
});

// Smooth scrolling for navigation links
function initSmoothScrolling() {
    const navLinks = document.querySelectorAll('a[href^="#"]');
    
    navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href');
            const targetElement = document.querySelector(targetId);
            
            if (targetElement) {
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        });
    });
}

// Form validation and submission
function initFormValidation() {
    const forms = document.querySelectorAll('form');
    
    forms.forEach(form => {
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            
            if (validateForm(this)) {
                submitForm(this);
            }
        });
        
        // Real-time validation
        const inputs = form.querySelectorAll('input, textarea');
        inputs.forEach(input => {
            input.addEventListener('blur', function() {
                validateField(this);
            });
        });
    });
}

function validateForm(form) {
    const inputs = form.querySelectorAll('input[required], textarea[required]');
    let isValid = true;
    
    inputs.forEach(input => {
        if (!validateField(input)) {
            isValid = false;
        }
    });
    
    return isValid;
}

function validateField(field) {
    const value = field.value.trim();
    const type = field.type;
    let isValid = true;
    let message = '';
    
    // Remove existing error styling
    field.classList.remove('error');
    const existingError = field.parentNode.querySelector('.error-message');
    if (existingError) {
        existingError.remove();
    }
    
    // Required field validation
    if (field.hasAttribute('required') && !value) {
        isValid = false;
        message = 'This field is required';
    }
    
    // Email validation
    if (type === 'email' && value) {
        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
        if (!emailRegex.test(value)) {
            isValid = false;
            message = 'Please enter a valid email address';
        }
    }
    
    // Show error if invalid
    if (!isValid) {
        field.classList.add('error');
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = message;
        field.parentNode.appendChild(errorDiv);
    }
    
    return isValid;
}

function submitForm(form) {
    const formData = new FormData(form);
    const data = Object.fromEntries(formData);
    
    // Show loading state
    const submitBtn = form.querySelector('button[type="submit"]');
    const originalText = submitBtn.textContent;
    submitBtn.textContent = 'Sending...';
    submitBtn.disabled = true;
    
    // Simulate form submission (replace with actual API call)
    setTimeout(() => {
        alert('Thank you for your message! We will get back to you soon.');
        form.reset();
        submitBtn.textContent = originalText;
        submitBtn.disabled = false;
    }, 2000);
}

// Shopping cart functionality
function initShoppingCart() {
    const cart = {
        items: [],
        total: 0,
        
        addItem(product) {
            const existingItem = this.items.find(item => item.id === product.id);
            if (existingItem) {
                existingItem.quantity += 1;
            } else {
                this.items.push({...product, quantity: 1});
            }
            this.updateCart();
        },
        
        removeItem(productId) {
            this.items = this.items.filter(item => item.id !== productId);
            this.updateCart();
        },
        
        updateQuantity(productId, quantity) {
            const item = this.items.find(item => item.id === productId);
            if (item) {
                item.quantity = Math.max(0, quantity);
                if (item.quantity === 0) {
                    this.removeItem(productId);
                } else {
                    this.updateCart();
                }
            }
        },
        
        updateCart() {
            this.total = this.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
            this.updateCartDisplay();
        },
        
        updateCartDisplay() {
            const cartElement = document.querySelector('.cart');
            if (cartElement) {
                cartElement.textContent = `Cart (${this.items.length})`;
            }
        }
    };
    
    // Add to cart buttons
    const addToCartBtns = document.querySelectorAll('.add-to-cart');
    addToCartBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            const productCard = this.closest('.product-card');
            const product = {
                id: Date.now(), // In real app, use actual product ID
                name: productCard.querySelector('h3').textContent,
                price: parseFloat(productCard.querySelector('p').textContent.replace('$', '')),
                image: productCard.querySelector('img').src
            };
            
            cart.addItem(product);
            
            // Visual feedback
            this.textContent = 'Added!';
            this.style.background = '#10b981';
            setTimeout(() => {
                this.textContent = 'Add to Cart';
                this.style.background = '';
            }, 1000);
        });
    });
    
    // Make cart globally available
    window.cart = cart;
}

// Mobile menu functionality
function initMobileMenu() {
    const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
    const navLinks = document.querySelector('.nav-links');
    
    if (mobileMenuBtn && navLinks) {
        mobileMenuBtn.addEventListener('click', function() {
            navLinks.classList.toggle('active');
            this.classList.toggle('active');
        });
        
        // Close menu when clicking on a link
        const links = navLinks.querySelectorAll('a');
        links.forEach(link => {
            link.addEventListener('click', () => {
                navLinks.classList.remove('active');
                mobileMenuBtn.classList.remove('active');
            });
        });
    }
}

// Lazy loading for images
function initLazyLoading() {
    const images = document.querySelectorAll('img[data-src]');
    
    const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                img.src = img.dataset.src;
                img.classList.remove('lazy');
                observer.unobserve(img);
            }
        });
    });
    
    images.forEach(img => imageObserver.observe(img));
}

// Animation on scroll
function initAnimations() {
    const animatedElements = document.querySelectorAll('.product-card, .service-card, .feature-card');
    
    const animationObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.style.opacity = '1';
                entry.target.style.transform = 'translateY(0)';
            }
        });
    }, { threshold: 0.1 });
    
    animatedElements.forEach(el => {
        el.style.opacity = '0';
        el.style.transform = 'translateY(20px)';
        el.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
        animationObserver.observe(el);
    });
}

// Utility functions
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function throttle(func, limit) {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// Error handling
window.addEventListener('error', function(e) {
    console.error('JavaScript Error:', e.error);
    // In production, send error to logging service
});

// Performance monitoring
window.addEventListener('load', function() {
    const loadTime = performance.now();
    console.log(`Page loaded in ${loadTime.toFixed(2)}ms`);
});
"""
